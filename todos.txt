[GENERAL]
1. Check if this works with Deno; 	

[v0.3]
2. Version Plan: Signatures. 

	The entire release is totally breaking. 
	Dedicated to fixing signatures. 

		ULTIMATE ISSUE TO SOLVE: 

			Currently (as of finished v0.2), the library supports: 

				1. Table-parsers; 
				2. Streams; 
				3. Self-modifying parsers; 
				4. Four (if not more) kinds of predicates; 
				5. Two (if not more) kinds of handlers; 
				6. Generators; 
				7. Tokenizers; 
				8. Trees
				9. Various essential utils for functional parser-building and most common/typical parsing tasks
				10. Validators; 
				11. A Locator; 
		
		Now, the ONLY thing that it really does not have 
			(but that which can be of essence, whenever building complex/exotic/unconventional syntaxes')
			is STATE! 
		Thus, the library must become STATEFUL (that is, 
			FUNCTION SIGNATURES MUST CHANGE IN A WAY TO RECIEVE SINGLE OBJECTS, 
				ONE OF PROPERTIES OF WHICH IS THE STATE!)

		This, of course, means that whatever signatures were still "present" 
		within the last release would erode in this one (and VERY fast). 

		The 'state'	must allow to carry: 

			1. 'streams' array (current - 'input', a single 'Stream'); [ALLOWS MULTISTREAMING]
			2. 'state' object (contains properties to be shared/mutated)
			3. 'parser' object/function (in dynamic cases - the ParserMap itself, in static - only just the function)
			4. 'result' - a 'Pushable': 

				4.1. This will have to be transformed into something that is both: A. General (as in v0.2); B. Powerful (like the builtin Array); 
					The final interface will have to both be an 'Array-equivalent' (in the sense that an 'Array' is viable), 
						and also be an interface (in that it can be implemented differently and be, for instance, of unlimited length).

				4.2. This is mutable; 
				4.3. This is a "list-like" result of the insofar obtained pieces of parsing

				In cases, when it's NOT an array (example: 'SourceGenerator'), one is to use an alternative with similar properties 
					(a 'Type'-equivalent, where 'Type' is the builtin type that it's supposed to "imitate", that is both potentially more powerful
						and equally capable of a given set of operations)
			5. 'finished' - a (modifiable) predicate, determining the point, at which the parsing function should halt (note: used by ALL the parsers): 
				There would be several predefined aliases for it, such as [SKETCHES (the actual things would be written in terms of the 5-object)]: 

					5.1. firstFinished = ({streams}) => streams[0].isEnd()
					5.2. allFinished = ({streams}) => streams.every((x) => x.isEnd())

			
		This signature will permit creation of parsers for syntaxes previously impossible. 
		Of course, the behaviour of present parsers will, too, have to be changed/generalized, 
			and the v0.3 API is not naturally compatible with the previous ones (although, as it is only singature - it can still be fixed).

		The "default" behaviour of the parser function will still be defined by things such as 'StreamParser' or `SkipParser`. 

		NOTE: the version would also have a lot of new functions for the interfaces (which would enable easier functional programming techniques application): 

			1. isEnd := (x) => x.isEnd()
			2. next := (x) => x.next()
			3. curr := (x) => x.curr()
			4. prev := (x) => x.prev()
			... [others...]

[v0.2]
3. Write proper JSDoc documentation for all this stuff...
4. Documentation
5. (Oh, the horror!) TESTING!

	First, decidee: 

		1. Whether to write tests in TypeScript (that is, whether the package is SUPPOSED to be used in TypeScript): 
			Most likely - they're to be in TypeScript (as one would love for the thing to be usable in TypeScript...)
	
	Second, write the tests and either (if it's in TypeScript) - compile, then TEST (run, fix bugs); 