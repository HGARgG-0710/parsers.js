[GENERAL]
1. Check if this works with Deno; 	

[v0.3]
2. Version Plan: Signatures. 

	The entire release is totally breaking. 
	Dedicated to fixing signatures. 

		ULTIMATE ISSUE TO SOLVE: 

			Currently (as of finished v0.2), the library supports: 

				1. Table-parsers; 
				2. Streams; 
				3. Self-modifying parsers; 
				4. Four (if not more) kinds of predicates; 
				5. Two (if not more) kinds of handlers; 
				6. Generators; 
				7. Tokenizers; 
				8. Trees
				9. Various essential utils for functional parser-building and most common/typical parsing tasks
				10. Validators; 
				11. A Locator; 
		
		Now, the ONLY thing that it really does not have 
			(but that which can be of essence, whenever building complex/exotic/unconventional syntaxes')
			is STATE! 
		Thus, the library must become STATEFUL (that is, 
			FUNCTION SIGNATURES MUST CHANGE IN A WAY TO RECIEVE SINGLE OBJECTS, 
				ONE OF PROPERTIES OF WHICH IS THE STATE!)

		This, of course, means that whatever signatures were still "present" 
		within the last release would erode in this one (and VERY fast). 

		The 'state'	must allow to carry: 

			1. 'streams' array (current - 'input', a single 'Stream'); [ALLOWS MULTISTREAMING]
			2. 'state' object (contains properties to be shared/mutated)
			3. 'parser' object/function (in dynamic cases - the ParserMap itself, in static - only just the function)
			4. 'result' - a 'Pushable': 

				4.1. This will have to be transformed into something that is both: A. General (as in v0.2); B. Powerful (like the builtin Array); 
					The final interface will have to both be an 'Array-equivalent' (in the sense that an 'Array' is viable), 
						and also be an interface (in that it can be implemented differently and be, for instance, of unlimited length).

				4.2. This is mutable; 
				4.3. This is a "list-like" result of the insofar obtained pieces of parsing

				In cases, when it's NOT an array (example: 'SourceGenerator'), one is to use an alternative with similar properties 
					(a 'Type'-equivalent, where 'Type' is the builtin type that it's supposed to "imitate", that is both potentially more powerful
						and equally capable of a given set of operations)
			5. 'finished' - a (modifiable) predicate, determining the point, at which the parsing function should halt (note: used by ALL the parsers): 
				There would be several predefined aliases for it, such as [SKETCHES (the actual things would be written in terms of the 5-object)]: 

					5.1. firstFinished = ({streams}) => streams[0].isEnd()
					5.2. allFinished = ({streams}) => streams.every((x) => x.isEnd())

			
		This signature will permit creation of parsers for syntaxes previously impossible. 
		Of course, the behaviour of present parsers will, too, have to be changed/generalized, 
			and the v0.3 API is not naturally compatible with the previous ones (although, as it is only singature - it can still be fixed).

		The "default" behaviour of the parser function will still be defined by things such as 'StreamParser' or `SkipParser`. 

		NOTE: the version would also have a lot of new functions for the interfaces (which would enable easier functional programming techniques application): 

			1. isEnd := (x) => x.isEnd()
			2. next := (x) => x.next()
			3. curr := (x) => x.curr()
			4. prev := (x) => x.prev()
			... [others...]

3. Idea for new functions: 

	NOTE: the 'utilities' and other parts of the library must ALL support the new 'stateful' signature...;

	3.1. a utility - 'find`: 2-layer of a `predcate` and a `Stream`; 

		It copies the given stream, and (from its current point), 
			finds all the elements of the stream that are in possession of the 
			desired property.
		It (then) proceeds to create an array of all the fitting stream elements.

		Predicate is also passed the 'i'; 
	3.2. a utility - 'revert' - reverts the stream, returns the copy

		Alters the stream, returns an array of all of its elements, 
			in reverse order.
	
	3.3. a utility - merge(mergeRule(...streams: Stream[]) => number, endRule: (...streams: Stream[]) => boolean, iterationRule: (...streams): Stream[])(...streams: Stream[]) - for merging separate streams 

		Iterates the '...streams' using 'iterationRule', until the moment that 
		`endRule` is false, and adds the 'streams[mergeRule(...streams)].curr()' to the final result (a general interface, of course...). 

	3.4. a utility - `extract`: 

		Reverse+generalization of 'limit' - splits a given Stream into 
			pieces, [extracted: any[][], remains: any[][]], 
			with: 
			
				Array(extracted.length).fill(0).map((_x, i) => [remains[i], extracted[i]]).flat().reduce((last, curr) => last.concat(curr), []) === transform((x) => x)(input)

		Where 'input' is the passed `Stream`.

		Useful for defining more complex predicate-based Pattern-s; 

	3.5. a utility-alias - `array` (same as `transform((x) => x)`)
	3.6. a utility `prolong` - concats the results of `transform((x) => x)`. 

		The result is an array consisting of elements of several different streams.

	3.7. StreamPattern: 

		A `Pattern` implementation based off `extract` and a `Stream`. 

	3.8. A general 'MultiIndex' interface, specific implementations. 

[v0.2]
3. Write proper JSDoc documentation for all this stuff...
4. Documentation
5. (Oh, the horror!) TESTING!

	First, decidee: 

		1. Whether to write tests in TypeScript (that is, whether the package is SUPPOSED to be used in TypeScript): 
			Most likely - they're to be in TypeScript (as one would love for the thing to be usable in TypeScript...)
	
	Second, write the tests and either (if it's in TypeScript) - compile, then TEST (run, fix bugs); 