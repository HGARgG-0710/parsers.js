1. Write proper JavaDoc-like documentation for all this stuff...
2. Check if this works with Deno; 

3. ? Use TypeScript for this thing? 

	Consider. Some of it can make (a little) sense. 

4. For future: CONSIDER: 

	The 'validation' and 'parsing' tools are separate. 
	Meanwhile, ofttimes, they are generated by THE SAME 
	syntax. 

	Use a structure somewhat similar to 'PEG's [parsing expression grammars]?

	[Except, generalized...];

5. IDEA: create a 'Locator' structure (StreamLocator): 

	Effectively, finds the first bit of given 'Stream' 
	that isn't correct. 

	NOTE: MUST have a 'pos'.
	
	It takes: 

		Level one: 
			1. validationMap - same as in the StreamValidator, an IndexMap; 
			2. errorMap - an IndexMap of [INDEX, ERROR], where ERROR is a string-like function of 'input'
				NOTE: the 'checks' in 'validationMap' now have to return one of: 
					1. true - for success; 
					2. [errorCode]: 'errorCode' is mapped against 'errorMap', to obtain the desired function, then 'input.error = ...(input)', where ... is the result of mapping. 
						After the mapping of error, the function exits. 
		Level two: 
			1. PositionalStream - the 'Stream' with an automatically changing '.pos' property.

	NOTE: the whole 'thing'/purpose of API is much more in the 'PositionalStream', because it must have properties:

		1. pos - last position
		2. error - error message

	Create the corresponding 'yell' function for "yelling" errors using these two properties based off a given stream. 
		NOTE: the 'yelling' would be conditional - only if 'error' is not 'null', which is the default value. 
	
	All the appropriate dependant-packages would also have a 0.2. version that would 
		include appropriate 'Locator's. 

6. Implement a left-to-right 'tree-inversion' algorithm. 
	
	Name: 'TreeReverseLR'
	Effectively, it reverses each of the levels of the tree. 

7. Implement top-to-bottom `tree-inversion` algorithm. 
	Same as above, but top-to-bottom. Name: `TreeReverseTB`.
	Switches parents and children.

	The 'TreeStream(TreeReverseTB(TreeReverseLR(tree)))' 
	causes '.next' to become '.prev' and vice versa. 

	Create an alias for this ('InvertTree := TreeReverseLR+TreeReverseTB').

8. add 'defaults' for maps to 'parsers.js' (NOTE: one is SUPPOSED to be able to do it NOT ONLY with the 'RegExpMap'-s...);
9. add a 'readWhile'/'readStream'/'read' function: 

	Effectively, an alias for 'delmited' - a simplification, with 'isdelim = () => false';
	It just reads everything until the end is reached

	NOTE: perhaps, for optimization purposes, define it differently? [To avoid unneccessary recursion...]; 
	ALSO - it would not have the 'limits' as an array - a simpler signature - just