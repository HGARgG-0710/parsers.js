1. For future: CONSIDER: 

	The 'validation' and 'parsing' tools are separate. 
	Meanwhile, ofttimes, they are generated by THE SAME 
	syntax. 

	Use a structure somewhat similar to 'PEG's [parsing expression grammars]?

	[Except, generalized...];

	NOTE: the (ultimate) advantage of the current approach over PEG 
		is that it can work with STATELY grammars 
			(those that permit infinite sets of different token types 
				generated by countable sets). 
		HOWEVER, as of present the library DOES NOT have any 'way'
			to store state within the parser - it's all functional, 
			ALL the "state" is inside 'Stream's. 

		IDEA: create a NEW Interface (for v0.3) - StatelyStream, 
			that would expand upon 'Stream', and also have a 
			publicly available 'state' property, 
			that can be mutated. 
		OR better still [ALTERNATIVE IDEA]: EXPAND the current 
			definitions to allow for a new 'state' object that 
			is passed around [then, any transformations upon 'state' is 
			all up to the user]. 

		TODO: Think about state and how to implement it within the 
		versions v0.2/v0.3 of the library, how to expand things accordingly...; 
	
[v0.2]
2. Write proper JSDoc documentation for all this stuff...
3. Check if this works with Deno; 

4. Implement the '.prev' inside of 'TreeStream' (in work); 
		
5. DynamicMapClass

	A MUTABLE 'MapClass'. 
	Interface is almost the same, HOWEVER, 
		the 'values' and 'keys' are MUTABLE PROPERTIES, that are referenced, 
		instead of being functions.

6. DynamicParser: 

	A very powerful thing, effectvely, a DYNAMIC version of the 'StreamParser'. 
	Its signature: 

		Level 1: 	
			1. dynamicMap - the 'DynamicMapClass(...)' instance, defininig the parser;
			2. initial (like with StreamParser) - the initial value, to which the values of the received 

		Level 2: 
			1. input: Stream - to be parsed
			
	'dynamicMap" is being 'parserChoice'-d ONCE, but on every step it additionally passed (for change), then the result is passed on 
		(along with the original 'map', when it is needed);
7. DynamicStreamTokenizer: 

	Same to the 'StreamTokenizer' as `DynamicParser` is to the 'StreamParser'
		(returns a 'Stream' used for parsing, AND every '.next()', 
			one can change the 'map' in question).
	
8. IDEA: a 'LayeredParser': 

	It is (in essence), a dynamic "composition" of different parsers.
	A list which (upon change) gets "re-composed" into a new function.

	So, EVERY TIME that is is changed the 'function' that it ultimately is, 
	gets re-composed...; 