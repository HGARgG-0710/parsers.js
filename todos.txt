1. For future: CONSIDER: 

	The 'validation' and 'parsing' tools are separate. 
	Meanwhile, ofttimes, they are generated by THE SAME 
	syntax. 

	Use a structure somewhat similar to 'PEG's [parsing expression grammars]?

	[Except, generalized...];

	NOTE: the (ultimate) advantage of the current approach over PEG 
		is that it can work with STATELY grammars 
			(those that permit infinite sets of different token types 
				generated by countable sets). 
		HOWEVER, as of present the library DOES NOT have any 'way'
			to store state within the parser - it's all functional, 
			ALL the "state" is inside 'Stream's. 

		IDEA: create a NEW Interface (for v0.3) - StatelyStream, 
			that would expand upon 'Stream', and also have a 
			publicly available 'state' property, 
			that can be mutated. 
		OR better still [ALTERNATIVE IDEA]: EXPAND the current 
			definitions to allow for a new 'state' object that 
			is passed around [then, any transformations upon 'state' is 
			all up to the user]. 

		TODO: Think about state and how to implement it within the 
		versions v0.2/v0.3 of the library, how to expand things accordingly...; 
	
[v0.2]
2. Write proper JSDoc documentation for all this stuff...
3. Check if this works with Deno; 
4. Use TypeScript for this thing

	Types would be VERY good. Permits greater clarity (PARTICULARLY in documentation...); 

5. IDEA: create a 'Locator' structure (StreamLocator): 

	Effectively, finds the first bit of given 'Stream' 
	that isn't correct. 

	NOTE: MUST have a 'pos'.
	
	It takes: 

		Level one: 
			1. validationMap - same as in the StreamValidator, an IndexMap; 
			2. errorMap - an IndexMap of [INDEX, ERROR], where ERROR is a string-like function of 'input'
				NOTE: the 'checks' in 'validationMap' now have to return one of: 
					1. true - for success; 
					2. [errorCode]: 'errorCode' is mapped against 'errorMap', to obtain the desired function, then 'input.error = ...(input)', where ... is the result of mapping. 
						After the mapping of error, the function exits. 
		Level two: 
			1. PositionalStream - the 'Stream' with an automatically changing '.pos' property.

	NOTE: the whole 'thing'/purpose of API is much more in the 'PositionalStream', because it must have properties:

		1. pos - last position
		2. error - error message

	Create the corresponding 'yell' function for "yelling" errors using these two properties based off a given stream. 
		NOTE: the 'yelling' would be conditional - only if 'error' is not 'null', which is the default value. 
	
	All the appropriate dependant-packages would also have a 0.2. version that would 
		include appropriate 'Locator's. 

6. Implement a left-to-right 'tree-inversion' algorithm. 
	
	Name: 'TreeReverseLR'
	Effectively, it reverses each of the levels of the tree. 

7. Implement top-to-bottom `tree-inversion` algorithm. 
	Same as above, but top-to-bottom. Name: `TreeReverseTB`.
	Switches parents and children.

	The 'TreeStream(TreeReverseTB(TreeReverseLR(tree)))' 
	causes '.next' to become '.prev' and vice versa. 

	Create an alias for this ('InvertTree := TreeReverseLR+TreeReverseTB').

8. Implement the '.prev' inside of 'TreeStream'; 
