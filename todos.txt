1. For future: CONSIDER: 

	The 'validation' and 'parsing' tools are separate. 
	Meanwhile, ofttimes, they are generated by THE SAME 
	syntax. 

	Use a structure somewhat similar to 'PEG's [parsing expression grammars]?

	[Except, generalized...];

	NOTE: the (ultimate) advantage of the current approach over PEG 
		is that it can work with STATELY grammars 
			(those that permit infinite sets of different token types 
				generated by countable sets). 
		HOWEVER, as of present the library DOES NOT have any 'way'
			to store state within the parser - it's all functional, 
			ALL the "state" is inside 'Stream's. 

		IDEA: create a NEW Interface (for v0.3) - StatelyStream, 
			that would expand upon 'Stream', and also have a 
			publicly available 'state' property, 
			that can be mutated. 
		OR better still [ALTERNATIVE IDEA]: EXPAND the current 
			definitions to allow for a new 'state' object that 
			is passed around [then, any transformations upon 'state' is 
			all up to the user]. 

		TODO: Think about state and how to implement it within the 
		versions v0.2/v0.3 of the library, how to expand things accordingly...; 
	
[v0.2]
2. Write proper JSDoc documentation for all this stuff...
3. Check if this works with Deno; 
4. Use TypeScript for this thing

	Types would be VERY good. Permits greater clarity (PARTICULARLY in documentation...); 

5. IDEA: create a 'Locator' structure (StreamLocator): 

	Effectively, finds the first bit of given 'Stream' 
	that isn't correct. 

	NOTE: MUST have a 'pos'.
	
	It takes: 

		Level one: 
			1. validationMap - same as in the StreamValidator, an IndexMap; 
			2. errorMap - an IndexMap of [INDEX, ERROR], where ERROR is a string-like function of 'input'
				NOTE: the 'checks' in 'validationMap' now have to return one of: 
					1. true - for success; 
					2. [errorCode]: 'errorCode' is mapped against 'errorMap', to obtain the desired function, then 'input.error = ...(input)', where ... is the result of mapping. 
						After the mapping of error, the function exits. 
		Level two: 
			1. PositionalStream - the 'Stream' with an automatically changing '.pos' property.

	NOTE: the whole 'thing'/purpose of API is much more in the 'PositionalStream', because it must have properties:

		1. pos - last position
		2. error - error message

	Create the corresponding 'yell' function for "yelling" errors using these two properties based off a given stream. 
		NOTE: the 'yelling' would be conditional - only if 'error' is not 'null', which is the default value. 
	
	All the appropriate dependant-packages would also have a 0.2. version that would 
		include appropriate 'Locator's. 

6. Implement a left-to-right 'tree-inversion' algorithm. 
	
	Name: 'TreeReverseLR'
	Effectively, it reverses each of the levels of the tree. 

7. Implement top-to-bottom `tree-inversion` algorithm. 
	Same as above, but top-to-bottom. Name: `TreeReverseTB`.
	Switches parents and children.

	The 'TreeStream(TreeReverseTB(TreeReverseLR(tree)))' 
	causes '.next' to become '.prev' and vice versa. 

	Create an alias for this ('InvertTree := TreeReverseLR+TreeReverseTB').

8. Implement the '.prev' inside of 'TreeStream'; 
9. For v0.2 - the 'ConditionalParser': 

	Works the same way as 'StreamParser', 

		BUT: instead of 'any[]' output from map-values functions, 
			it expects an [n, any[]], 
			with the first being the number of steps/predicate to skip, 
			and 'any[]' being the value to be added to the final array;
		
		Output is of the same type...;
		
10. MILDLY BREAKING CHANGE [idea]: 

	Re-do the 'TreeStream'. 
	It would (from that moment on)
		instead of 'children' have an 'isChild'
		method (which would check whether a child at a given index is 'legal'). 

	The difference is that there DOES NOT HAVE TO BE an underlying data structure.
	This would permit: 

		1. More room for optimization of 'rigid' structures (less allocation, simpler checks); 
		2. More general interface;
11. GET RID of '[]' in StreamParser (and other places): 

	Replace with an arbitrary object passed by user as a second arg (default is '[]'). 
	Allows to easily generalize to arbitrary interfaces.

12. DynamicMapClass

	A MUTABLE 'MapClass'. 
	Interface is almost the same, HOWEVER, 
		the 'values' and 'keys' are MUTABLE PROPERTIES, that are referenced, 
		instead of being functions.

12. DynamicParser: 

	A very powerful thing, effectvely, a DYNAMIC version of the 'StreamParser'. 
	Its signature: 

		Level 1: 	
			1. dynamicMap - the 'DynamicMapClass(...)' instance, defininig the parser;
			2. initial (like with StreamParser) - the initial value, to which the values of the received 

		Level 2: 
			1. input: Stream - to be parsed
			
	'dynamicMap" is being 'parserChoice'-d ONCE, but on every step it additionally passed (for change), then the result is passed on 
		(along with the original 'map', when it is needed);
13. DynamicStreamTokenizer: 

	Same to the 'StreamTokenizer' as `DynamicParser` is to the 'StreamParser'
		(returns a 'Stream' used for parsing, AND every '.next()', 
			one can change the 'map' in question).
	
14. IDEA: a 'LayeredParser': 

	It is (in essence), a dynamic "composition" of different parsers.
	A list which (upon change) gets "re-composed" into a new function.

	So, EVERY TIME that is is changed the 'function' that it ultimately is, 
	gets re-composed...; 